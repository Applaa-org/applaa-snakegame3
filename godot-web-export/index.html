<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SnakeGame3 Preview</title>
    <style>
        body { margin: 0; background-color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; color: white; }
        canvas { background-color: #363; border: 2px solid #eee; }
        .screen { display: none; text-align: center; }
        .screen.active { display: block; }
        h1 { font-size: 3em; }
        p { font-size: 1.2em; }
        button { font-size: 1.5em; padding: 10px 20px; margin: 10px; cursor: pointer; background-color: #555; border: 2px solid #eee; color: white; }
        button:hover { background-color: #777; }
    </style>
</head>
<body>

    <div id="start-screen" class="screen active">
        <h1>SnakeGame3</h1>
        <p>Use W/A/S/D or Arrow Keys to move.<br>Eat the apples to grow and score points.<br>Avoid hitting the walls or your own tail!</p>
        <button id="start-btn">Start Game</button>
        <button id="close-btn-start">Close Game</button>
    </div>

    <div id="game-screen" class="screen">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="end-screen" class="screen">
        <h1 id="end-title">Game Over</h1>
        <p id="final-score">Final Score: 0</p>
        <button id="restart-btn">Play Again</button>
        <button id="menu-btn">Main Menu</button>
        <button id="close-btn-end">Close Game</button>
    </div>

    <script>
        # ... continuing from above
const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        const endScreen = document.getElementById('end-screen');

        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const menuBtn = document.getElementById('menu-btn');
        const closeBtns = [document.getElementById('close-btn-start'), document.getElementById('close-btn-end')];
        
        const endTitle = document.getElementById('end-title');
        const finalScoreLabel = document.getElementById('final-score');

        const GRID_SIZE = 20;
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;
        const GAME_AREA_X = 20;
        const GAME_AREA_Y = 60;
        const GAME_AREA_WIDTH = 760;
        const GAME_AREA_HEIGHT = 520;

        let snake, food, score, direction, nextDirection, gameInterval, isGameOver;

        function resetGame() {
            snake = [{ x: 400, y: 300 }];
            direction = { x: GRID_SIZE, y: 0 };
            nextDirection = { x: GRID_SIZE, y: 0 };
            score = 0;
            isGameOver = false;
            spawnFood();
        }

        function spawnFood() {
            let validPosition = false;
            while (!validPosition) {
                food = {
                    x: Math.floor(Math.random() * (GAME_AREA_WIDTH / GRID_SIZE)) * GRID_SIZE + GAME_AREA_X,
                    y: Math.floor(Math.random() * (GAME_AREA_HEIGHT / GRID_SIZE)) * GRID_SIZE + GAME_AREA_Y
                };
                validPosition = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }

        function update() {
            if (isGameOver) return;

            direction = nextDirection;
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            // Wall collision
            if (head.x < GAME_AREA_X || head.x >= GAME_AREA_X + GAME_AREA_WIDTH ||
                head.y < GAME_AREA_Y || head.y >= GAME_AREA_Y + GAME_AREA_HEIGHT) {
                endGame(false);
                return;
            }

            // Self collision
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    endGame(false);
                    return;
                }
            }

            snake.unshift(head);

            // Food collision
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                if (score >= 100) {
                    endGame(true); // Victory
                } else {
                    spawnFood();
                }
            } else {
                snake.pop();
            }

            draw();
        }

        function draw() {
            // Background
            ctx.fillStyle = '#2d472d';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Game Area
            ctx.fillStyle = '#111';
            ctx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

            // Snake
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#0f0' : '#8f8';
                ctx.fillRect(segment.x, segment.y, GRID_SIZE, GRID_SIZE);
                ctx.strokeStyle = '#111';
                ctx.strokeRect(segment.x, segment.y, GRID_SIZE, GRID_SIZE);
            });

            // Food
            ctx.fillStyle = '#f00';
            ctx.fillRect(food.x, food.y, GRID_SIZE, GRID_SIZE);

            // Score
            ctx.fillStyle = 'white';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Score: ${score}`, GAME_WIDTH / 2, 40);
        }

        function showScreen(screenId) {
            startScreen.classList.remove('active');
            gameScreen.classList.remove('active');
            endScreen.classList.remove('active');
            document.getElementById(screenId).classList.add('active');
        }

        function startGame() {
            resetGame();
            showScreen('game-screen');
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(update, 150);
        }

        function endGame(isVictory) {
            isGameOver = true;
            clearInterval(gameInterval);
            if (isVictory) {
                endTitle.textContent = "You Win!";
            } else {
                endTitle.textContent = "Game Over";
            }
            finalScoreLabel.textContent = `Final Score: ${score}`;
            showScreen('end-screen');
        }

        document.addEventListener('keydown', e => {
            switch (e.key) {
                case 'w':
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -GRID_SIZE };
                    break;
                case 's':
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: GRID_SIZE };
                    break;
                case 'a':
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -GRID_SIZE, y: 0 };
                    break;
                case 'd':
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: GRID_SIZE, y: 0 };
                    break;
            }
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        menuBtn.addEventListener('click', () => showScreen('start-screen'));
        closeBtns.forEach(btn => btn.addEventListener('click', () => {
            // In a real Godot export, this would be get_tree().quit().
            // For the web preview, we can just show a message.
            document.body.innerHTML = '<h1>Thanks for playing!</h1><p>You can close this browser tab.</p>';
        }));

    </script>
</body>
</html>